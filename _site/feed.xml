<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title></title>
		<description>Stylish Jekyll Theme</description>
		<link>/</link>
		<atom:link href="/feed.xml" rel="self" type="application/rss+xml" />
		
			<item>
				<title>计算机网络IO模型原理性解析</title>
				<description>&lt;p&gt;  本文旨在原理性的揭示计算机网络IO模型以及select、epoll的区别，而并不探讨实现细节，另外，讨论阻塞与非阻塞、同步和异步时往往是上下文相关的，本文的上下文就是Linux IO，下文中IO操作就以read为例。&lt;br /&gt;
首先明确一点，一次IO操作分为两个阶段：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;等待数据准备就绪&lt;/li&gt;
  &lt;li&gt;将数据从内核拷贝到用户进程空间  &lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;阻塞IO：&lt;/strong&gt;&lt;br /&gt;
        首先用户进程发起read系统调用，内核开始准备数据，一般的，对于网络IO来说，大部分情况下当用户进程发起read系统调用的时候数据尚未到达，这个时候内核一直等待数据到达，在用户进程这一侧，整个进程会被阻塞。当数据到达后，内核就把准备妥当的数据从内核空间拷贝用户进程空间，然后内核返回，用户进程被唤醒，因此，阻塞IO在一次IO操作的两个阶段均被阻塞了。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;非阻塞IO：&lt;/strong&gt;&lt;br /&gt;
        当用户进程发起read系统调用时，如果内核还没收到数据，则此次系统调用立即返回一个错误而不是阻塞整个进程，用户进程需要通过此次调用的返回值判断是否读到了数据，如果没有则隔一段时间再次发起read调用，如此不断轮询，在用户进程轮询期间，内核一直在等待数据到达，当数据准备妥当后，当用户进程发起当read系统调用时，内核负责将数据拷贝到用户进程空间，直到拷贝完成，read操作返回，也就是在这一阶段（第二阶段），非阻塞IO表现出的其实是一个同步操作，因此，从内核拷贝数据到用户进程空间的这段时间内read调用是一直等待直到完成的，所以，非阻塞IO是属于同步IO，也就是说非阻塞IO操作在第一阶段是不阻塞的，在第二阶段是阻塞的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;同步IO：&lt;/strong&gt;&lt;br /&gt;
        一个同步IO操作会导致进程阻塞直到IO操作完成，所以，阻塞IO、非阻塞IO以及本文未提及到的IO多路复用都属于同步IO。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;异步IO：&lt;/strong&gt;&lt;br /&gt;
        一个异步IO操作不会引起进程的阻塞。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;  这里面大家可能分不清阻塞和非阻塞IO，甚至会认为非阻塞就是同步了，其实不是的，回到本文开头，我们说一次IO操作分两个阶段，第一阶段是等待数据，第二阶段拷贝数据（内核到用户空间），非阻塞IO操作在数据还没有到达时是立即返回到，这一点表现的跟异步一样，但是，在第二阶段，当数据准备妥当的时候，非阻塞IO是阻塞的，直到数据拷贝完成，这一点表现的与同步IO完全不一样，异步操作根本不关心你的数据是否到达以及你的数据是否拷贝完成，异步发起一次操作后就去干别的事儿了，直到内核发出一个信号通知这一事件，它才会转回来继续处理。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;select与epoll&lt;/strong&gt;&lt;br /&gt;
        select与epoll都是IO多路复用模型，它们都是监视一组文件描述符（在本文就是socket）上是否有数据准备就绪，select和epoll会一直阻塞直到它们监视的一个或多个套接字描述符上数据准备就绪，当在某个或某几个套接字描述符上有数据到达时，对select而言，它需要遍历这组描述符以确定到底是哪一个描述符上面有数据到达了，所以时间复杂度是O(n)，而对于epoll而言，它不是通过遍历或者叫轮询的方式来确定数据准备妥当的描述符，而是通过事件的方式，以事件的方式通知epoll是哪个描述符上数据到达来，因此，时间复杂度是O(1)。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;  可能说的很啰嗦，只是想尽量的把原理讲清楚，原理清楚来再看实现细节才能做到游刃有余。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;参考文章:&lt;/strong&gt;&lt;br /&gt;
        &lt;a href=&quot;http://blog.csdn.net/historyasamirror/article/details/5778378&quot;&gt;http://blog.csdn.net/historyasamirror/article/details/5778378&lt;/a&gt;&lt;br /&gt;
        &lt;a href=&quot;http://yaocoder.blog.51cto.com/2668309/888374&quot;&gt;http://yaocoder.blog.51cto.com/2668309/888374&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
				<pubDate>Wed, 21 May 2014 00:00:00 +0800</pubDate>
				<link>/linux/2014/05/21/computer-net-io.html</link>
				<guid isPermaLink="true">/linux/2014/05/21/computer-net-io.html</guid>
			</item>
		
			<item>
				<title>PHP编译扩展时解析器出错</title>
				<description>&lt;p&gt;  编译PHP扩展时出现出错，操作步骤如下：  &lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;cd path/to/php-src/ext&lt;/li&gt;
  &lt;li&gt;./ext_skel –extname=example&lt;/li&gt;
  &lt;li&gt;cd ..&lt;/li&gt;
  &lt;li&gt;./buildconf&lt;/li&gt;
  &lt;li&gt;./configure –with-example&lt;/li&gt;
  &lt;li&gt;make&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;  ok，就在编译的时候解析器报错：  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;path/to/php-src/Zend/zend_language_parser.y:50.1-5: invalid directive: `%code&#39;
path/to/php-src/Zend/zend_language_parser.y:50.7-14: syntax error, unexpected &quot;identifier&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  原因是 &lt;code&gt;%coe&lt;/code&gt; 是 &lt;code&gt;bison2.3+&lt;/code&gt; 之后才引入的，我的机器上 &lt;code&gt;bison&lt;/code&gt; 的版本是 &lt;code&gt;1.875c&lt;/code&gt; ，因此不支持，解决方法是：  &lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;下载高版本的 &lt;code&gt;bison&lt;/code&gt; 并安装；&lt;/li&gt;
  &lt;li&gt;或者修改 &lt;code&gt;path/to/php-src/Zend/zend_language_parser.y&lt;/code&gt; ，由于我没有 &lt;code&gt;root&lt;/code&gt; 权限，&lt;code&gt;bison&lt;/code&gt; 是安装在 &lt;code&gt;/usr/bin/&lt;/code&gt; 的，因此采用方案2&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;  具体如下：  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;将%code requires { 修改为%{
将} 修改为%}

make clean &amp;amp;&amp;amp; make
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  Ok.&lt;/p&gt;

</description>
				<pubDate>Tue, 13 May 2014 00:00:00 +0800</pubDate>
				<link>/programming/2014/05/13/php_ext_compile_error.html</link>
				<guid isPermaLink="true">/programming/2014/05/13/php_ext_compile_error.html</guid>
			</item>
		
			<item>
				<title>C++成员初始化</title>
				<description>&lt;p&gt;  我们知道在C++里，对象的构造是有构造函数完成的，一般的，我们会在构造函数体内完成成员的初始化工作，像下面这样：  &lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;X&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;  这是比较简单的一种情况，也是最常用的一种方式，因为它没有涉及到有虚函数以及继承链里有虚基类的情况。在有虚函数的情况下，一般是编译器会在构造函数中（由编译器合成或者开发者提供）安插vptr指针，并妥当设置好它的值，使得它指向该类的虚函数表，虚函数表也是在编译期间完成的，这里不再展开细说。  &lt;/p&gt;

&lt;p&gt;  构造函数的另外一种语法就是本文的主题：&lt;em&gt;成员初始化列表&lt;/em&gt; 。像下面这样：  &lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;X&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;  成员初始化列表并不是一种函数调用，初始化成员的次序非常讲究，编译器真正初始化成员的顺序是它们在类中申明的次序，而并不是列在成员初始化列表里的顺序，上面的示例没有任何问题，咱们再来看另外一种情况，你会得到一个怪异的结果：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;X&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;  看出区别了吗？成员初始化列表里面的次序发生了变化，我们来简单的测试一下到底有什么不同：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
    
&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;X&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
    
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;X&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;  输出结果：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;   再来看后一种情况：  &lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
    
&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;X&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
    
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;X&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;   输出结果：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;mi&quot;&gt;10653684&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;  显然这不是我们想要的结果，这是因为，编译器是按照申明次序来初始化的，所以先初始化i，这时候j是未初始化过的，因此得到的是脏数据。gcc／g++能对这种情况给出warning，像下面这样：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Wall&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;O3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cpp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;cpp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;In&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;constructor&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;cpp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;12&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;warning&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;#39;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;will&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;be&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;initialized&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;after&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;cpp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;warning&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;   &lt;span class=&quot;err&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;#39;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;cpp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;warning&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;when&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;initialized&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;here&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;  如果没有对成员初始化列表有这样的理解，这样的警告会让人很困惑，另外，下面四种情况下是必须要用成员初始化列表的语法来初始化成员的：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;初始化一个reference member&lt;/li&gt;
  &lt;li&gt;初始化一个const member&lt;/li&gt;
  &lt;li&gt;调用一个base class的构造函数，而它拥有一组参数&lt;/li&gt;
  &lt;li&gt;调用一个member class的构造函数，而它拥有一组参数&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;  最后一点，当成员都是基本类型时，两种构造方法在效率上没有任何区别，当成员有class对象时，情况就不一样，在构造函数体中通过赋值运算符＝进行初始化时，会产生临时对象，在用成员初始化列表进行构造时，会直接调用class成员的copy构造函数，效率上会有所提升，不过现在的编译器会做何种优化也视不同的编译器而异。举个例子：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Word&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Word&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cnt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cnt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;  编译器对构造函数可能做的扩张如下：  &lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;n&quot;&gt;Word&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Word&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;temp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;temp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;temp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::~&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cnt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;   另外一个例子：  &lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Word&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Word&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;cnt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cnt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;   编译器对构造函数做对扩展可能如下：  &lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;n&quot;&gt;Word&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Word&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cnt&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;   完！&lt;/p&gt;

</description>
				<pubDate>Sun, 21 Apr 2013 00:00:00 +0800</pubDate>
				<link>/programming/2013/04/21/cpp-member-init.html</link>
				<guid isPermaLink="true">/programming/2013/04/21/cpp-member-init.html</guid>
			</item>
		
			<item>
				<title>Win7下安装CentOS 5.8双系统</title>
				<description>&lt;p&gt;  上周末看到自己的机器跑的也慢了，再加上不想在虚拟机下学linux了，因此，想装个双系统，看到鸟哥的私房菜是在CentOS 5.X下进行演示，索性就装个CentOS吧，在这里装的是CentOS的5.8版本CentOS 5.8，下载 &lt;em&gt;CentOS-5.8-i386-bin-DVD-1of2.iso&lt;/em&gt; 和 &lt;em&gt;CentOS-5.8-i386-bin-DVD-1of2.iso&lt;/em&gt; 这个两个镜像。  &lt;/p&gt;

&lt;p&gt;  在这里先插入一段小插曲，就是安装win7的时候出现了让人郁闷的事情，我是分了四个区，win7安装在C盘，装完之后，发现所有分区都是动态类型的，如果只用win7一个系统那么没什么关系的其实，但是要装双系统就不能是动态类型，然后就重装了下win7，但是到分区那一步的时候发现居然不能操作，无法删除也无法格式化，然后查了下资料，方法就是，在分区那一步，按 &lt;code&gt;shift+F10&lt;/code&gt; 调出dos命令提示符窗口，分别执行以下操作：  &lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;键入 &lt;code&gt;diskpart&lt;/code&gt; 命令，进入diskpart环境;&lt;/li&gt;
  &lt;li&gt;键入 &lt;code&gt;list disk&lt;/code&gt; 命令，列出本机所有磁盘;&lt;/li&gt;
  &lt;li&gt;键入 &lt;code&gt;select disk 0&lt;/code&gt; 命令，选择第一个磁盘;&lt;/li&gt;
  &lt;li&gt;键入 &lt;code&gt;clean&lt;/code&gt; 命令，清除分区。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;  到这一步其实事情已经解决了，你在返回分区界面刷新一下就能看到效果了，在这里如果想灵活的分出主分区和逻辑分区，在dos diskpart命令环境下很方便的，比如 &lt;code&gt;create primary partition size=51200&lt;/code&gt; 创建一个大小为50G的主分区，然后用 &lt;code&gt;active&lt;/code&gt; 命令激活，再比如 &lt;code&gt;create partition extended&lt;/code&gt; 命令创建扩展分区等。在这里我我分了四个分区，一个主分区，三个逻辑分区，最后一个分区F盘大小为60G准备安装我的CentOS。好了，插曲就到这里，下面看看CentOS的安装方法：  &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;首先准备启动盘&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;  启动盘可以是U盘、硬盘和光盘，用U盘和光盘制作启动镜像来安装应该是最简单的方式，但是本人手边木有那么大的U盘也没有一张光盘，就选择用硬盘安装。首先用分区工具 Acronis Disk Director Suite 从E盘分出5G空间用来存放CentOS安装文件，为方便起见，在这里称其为”安装分区“，但是linux只识别ext2/ext3/ext4或者fat32这样的文件系统，因此不能划分完就完事了，我们知道windows也识别fat32文件系统，因此将”安装分区“格式化为fat32系统，其实这里还有个问题，那就是fat32系统只识别4G以下的文件，如果你的CentOS镜像大于4G了那么就不能放在fat32文件系统下面，你要将其格式化ext3等linux识别的文件系统，再用Ext2Fs这样的工具去把安装镜像放到里面，如果不用这个工具的话windows是不识别ext文件系统的，更别说把文件拷进去了。再说说这里为什么可以用fat32文件系统，我们看到我们下载下来的安装文件有两个iso，第一个是3G多不到4G，第二个不到1G，但是加一起就大于4G了，但是没关系，单个文件小于4G就OK。再用UltraISO将 &lt;em&gt;CentOS-5.8-i386-bin-DVD-1of2.iso&lt;/em&gt;中的&lt;em&gt;isolinux/vmlinuz&lt;/em&gt; 和 &lt;em&gt;isolinux/initrd.img&lt;/em&gt; 以及&lt;em&gt;imgs&lt;/em&gt; 放到我们刚刚划分好的”安装分区”里面，最后”安装分区”里面应该有5个文件，分别是 &lt;em&gt;CentOS-5.8-i386-bin-DVD-1of2.iso&lt;/em&gt;、&lt;em&gt;CentOS-5.8-i386-bin-DVD-2of2.iso&lt;/em&gt;、&lt;em&gt;vmlinuz&lt;/em&gt;、&lt;em&gt;initrd.img&lt;/em&gt;和&lt;em&gt;imgs&lt;/em&gt;，如果只放&lt;em&gt;DVD1&lt;/em&gt;可能会让你在最后快完成安装的时候喷血，会提示镜像找不到的错误。OK，到这里我们的启动盘准备完成。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;添加启动菜单&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;  下载并安装&lt;em&gt;EasyBCD&lt;/em&gt;来为我们刚刚做的启动盘添加一个启动项以便进入安装环节。打&lt;em&gt;开EasyBCD&lt;/em&gt;，&lt;em&gt;AddNewEntry-&amp;gt;Install-&amp;gt;Config&lt;/em&gt;，这时会弹出一个&lt;em&gt;txt&lt;/em&gt;文件，这个文件其实就是&lt;em&gt;menulist&lt;/em&gt;文件，在其中键入如下值：  &lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;title CentOS 5.8&lt;br /&gt;
kernel  (hd0,6)/vmlinuz&lt;br /&gt;
initrd  (hd0,6)/initrd.img  &lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;  保存并退出。  &lt;/p&gt;

&lt;p&gt;  在这里，解释一下&lt;em&gt;menulist&lt;/em&gt;中的这些东西。title后面的内容只是一个标题，写错写对无伤大雅，下面的kernel和initrd后面其实是vmlinuz和initrd.img的路径，不管你的本的磁盘接口是IDE的还是SATA的都是以hd来标记，比如hd0表示你的第一个磁盘，括号内的第二个数字表示对应的磁盘上的分区号，在这里要写对应的”安装分区“的分区号，我的本上的分区是这样的一个主分区C盘，两个逻辑分区D盘和E盘，后面是一个刚刚从C盘剥离出来的”安装分区“以及最后的一个F盘，由于分区号0~3是给主分区或者可扩展分区的，因此这里C盘的分区号就是0，D、E、”安装分区“、F分别是4、5、6、7。这个别写错了，否则在安装的时候会因为找不见vmlinuz和initrd.img文件而失败。OK，到这里我们已经给我们的启动盘添加了启动项，接下来重启选择第二个菜单进入安装。  &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;安装CentOS5.8&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;  这个环节基本上就是一路”next“的节奏，稍微注意一下的是在选择安装文件的时候要选择sd7否则会找不着安装文件，其实这个没什么，实在不知道自己的安装文件丢到那个分区里了就挨个试一试，总有一个会成功的。再就是最重要的分区，在这里选择”建立自定义的分区结构“，点”确定“，这时候我们会在上面区域看到我们的磁盘分区情况，我是想装在F盘，但是这个分区是在装win7的时候分出来的，是NTFS文件系统，因此我们在这里首先要删除这个分区，这时候会看到Free后面跟一个代表大小的数字，OK，我们就从这个free里面为我们的linux分区。在这里分四个区，分别是/、/boot、/home、swap区，由于我预先留出来的空间比较大有60G，因此在这里给/根区分20G，给/boot分200M，给swap分4G，剩下的全分给/home。好了，这些步骤都完成后，我就分好区了，接下来还有一个一定要注意的地方，那就是安装引导装载程序grub，我们要把它安装在MBR上才能进行引导，其实默认也是安装在MBR里头的，/dev/hda就代表了那块硬盘的MBR，下面有个列表区域，就是你开机时候出现的菜单。  &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;关于引导的一些问题&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;  安装完后重启，默认引导是由grub来引导的，默认的系统是CentOS，但是如果我们在大部分时间内用的是windows的话这样很不方便，因此建议进入CentOS系统后，切换到root用户，然后gedit /etc/grub.conf，然后将default=0改为default=1就会默认启动windows。至此，已经大功告成了，开始你的CentOS吧。  &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;其他&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;  到这一步，按理应该是在玩windows或者CentOS才对，可是我却干了一件麻烦事。切换到win7的时候我们会看到我们一开始制作的那个”安装分区“，就5G摆在那里总觉得别扭，然后我手闲闲的将其和邻近的E盘合并了，一切看起来似乎很完美，但当我再次重启想进CentOS时发现没能正常启动grub，出现的是一个grub命令提示符，其实这个原因是因为你把一个分区与另一个分区合并之后，那个被合并的分区之后的所有分区的编号都减一了，而你在/etc/grub.conf的root (hd0,7)就不在适用了，应该改为(hd0,6) 才对，这里的root命令用来设定/boot分区的，因为没合并那两个分区前，有C、D、E、”安装分区“、/boot、/、/home、/swap，因此，/boot就是(hd0,7)，但是合并了E盘和”安装分区“后，/boot的编号应该为(hd0,6)才对。OK，在grub命令提示符下键入以下命令：  &lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;setup (hd0)  //重新安装grub在MBR上&lt;/li&gt;
  &lt;li&gt;reboot  //重启&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;  这时候还是会出现grub命令提示符，这是肯定的，因为我们并没有修改gurb.conf文件，现在就来做这件事：  &lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;root (hd0,6)  //设定/boot分区&lt;/li&gt;
  &lt;li&gt;kernel /vmlinuz-2.6.18.308.e15 ro root=LABEL=/  rhgb quiet  //你可以用tab键补全&lt;/li&gt;
  &lt;li&gt;initrd /initrd-2.6.18.308.e15.img  //你可以用tab键补全&lt;/li&gt;
  &lt;li&gt;boot&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;  OK，我们会看到我们的CentOS又可以顺利的启动了！进入之后，记得把/boot/grub/grub.conf进行修改，主要就是把/boot的分区号给对应上，我这里就是把(hd0,7)改为(hd0,6)。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;最后，还要感谢我可爱的老婆陪着我 ^_^ 。&lt;/li&gt;
&lt;/ul&gt;
</description>
				<pubDate>Mon, 19 Nov 2012 00:00:00 +0800</pubDate>
				<link>/linux/2012/11/19/install_centos58_on_win.html</link>
				<guid isPermaLink="true">/linux/2012/11/19/install_centos58_on_win.html</guid>
			</item>
		
			<item>
				<title>win32程序在64位机器上读取system目录下文件失败</title>
				<description>&lt;p&gt;  今天做项目的时候碰到一个问题，就是要去遍历系统的所有进程，然后获取每个进程的镜像全路径，进而对其做一些非破坏性的处理，然后在用&lt;code&gt;_tfopen_s&lt;/code&gt;以二进制读模式打开的时候，发现在64位vista和64位win7上某些文件访问不到，比如“C:\Windows\System32\smss.exe”，还有好多，这里就不在一一列举了。然后我就很郁闷是不是库函数在64位下出了什么问题，然后改用系统函数&lt;code&gt;CreateFile&lt;/code&gt;以共享读模式打开文件，结果还是一样，没有任何改变，再&lt;code&gt;GetLastError&lt;/code&gt;了一下，返回值为2，也就是找不到指定的文件，但是该文件确实存在啊，怎么会这样呢，然后就是各种查查查，后来看到&lt;code&gt;Wow64DisableWow64FsRedirection&lt;/code&gt;，试了一下就好使了，具体用法如下：  &lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;BOOL&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WINAPI&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WDWFD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_Out_&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;PVOID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    
&lt;span class=&quot;n&quot;&gt;WDWFD&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pWdwfd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WDWFD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GetProcAddress&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GetModuleHandle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Kernel32.dll&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)),&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Wow64DisableWow64FsRedirection&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pWdwfd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;pWdwfd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;  在你需要打开文件的前面加上上述代码，OK，不管是32位机器还是64位机器就都好使了。&lt;/p&gt;
</description>
				<pubDate>Fri, 14 Sep 2012 00:00:00 +0800</pubDate>
				<link>/programming/2012/09/14/win32_sysdir_on_win64.html</link>
				<guid isPermaLink="true">/programming/2012/09/14/win32_sysdir_on_win64.html</guid>
			</item>
		
			<item>
				<title>visual studio 2010 msdn 更改路径</title>
				<description>&lt;p&gt;  visual studio 2010的msdn默认是安装在C:/ProgramData/Microsoft/HelpLibrary，而且是不能更改的，如果将msdn装齐的话会很大，想要安装到其他盘符下可以通过以下几步完成，比如改到E:/HelpLibrary：  &lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;找到C:/ProgramData/Microsoft/HelpLibrary，把HelpLibrary文件夹下的所有内容复制到E:/HelpLibrary&lt;/li&gt;
  &lt;li&gt;打开注册表，找到HKEY_LOCAL_MACHINE/SOFTWARE/Microsoft/Help/v1.0，此处有一个LocalStore的值 .数据就是之前默认保存的路径了.先备份一下,然后替换成自己想要的文件夹路径E:/HelpLibrary&lt;/li&gt;
  &lt;li&gt;找到文件C:/Program Files/HelpLibrary/manifest/queryManifest.3.xml，进行编辑：找到下面两行：
    &lt;ul&gt;
      &lt;li&gt;
        &lt;catalogpath&gt;C:/ProgramData/Microsoft/HelpLibrary/catalogs/VS/100/EN-US&lt;/catalogpath&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;contentpath&gt;C:/ProgramData/Microsoft/HelpLibrary/content&lt;/contentpath&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;将C:/ProgramData/Microsoft改为E:即可&lt;/li&gt;
&lt;/ol&gt;

</description>
				<pubDate>Wed, 28 Sep 2011 00:00:00 +0800</pubDate>
				<link>/tools/2011/09/28/change_msdn_path.html</link>
				<guid isPermaLink="true">/tools/2011/09/28/change_msdn_path.html</guid>
			</item>
		
			<item>
				<title>unix之fork</title>
				<description>&lt;p&gt;  直接看代码：  &lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;unistd.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;pid_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fork&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;error in fork!&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;i am the child process, my process id is %dn&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getpid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;i am the parent process, my process id is %dn&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getpid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;  执行结果是：  &lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;i am the parent process, my process id is 2826&lt;br /&gt;
i am the child process, my process id is 2827&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;  要搞清楚fork的执行过程，就必须先讲清楚操作系统中的“进程(process)”概念。一个进程，主要包含三个元素：  &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;一个可以执行的程序;&lt;/li&gt;
  &lt;li&gt;和该进程相关联的全部数据（包括变量，内存空间，缓冲区等等）;&lt;/li&gt;
  &lt;li&gt;程序的执行上下文（execution context）。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;  不妨简单理解为，一个进程表示的，就是一个可执行程序的一次执行过程中的一个状态。操作系统对进程的管理，典型的情况，是通过进程表完成的。进程表中的每一个表项，记录的是当前操作系统中一个进程的情况。对于单 CPU的情况而言，每一特定时刻只有一个进程占用 CPU，但是系统中可能同时存在多个活动的（等待执行或继续执行的）进程。  &lt;/p&gt;

&lt;p&gt;  一个称为“程序计数器（program counter, pc）”的寄存器，指出当前占用 CPU的进程要执行的下一条指令的位置。   &lt;/p&gt;

&lt;p&gt;  当分给某个进程的 CPU时间已经用完，操作系统将该进程相关的寄存器的值，保存到该进程在进程表中对应的表项里面；把将要接替这个进程占用 CPU的那个进程的上下文，从进程表中读出，并更新相应的寄存器（这个过程称为“上下文交换(process context switch)”，实际的上下文交换需要涉及到更多的数据，那和fork无关，不再多说，主要要记住程序寄存器pc指出程序当前已经执行到哪里，是进程上下文的重要内容，换出 CPU的进程要保存这个寄存器的值，换入CPU的进程，也要根据进程表中保存的本进程执行上下文信息，更新这个寄存器）。&lt;/p&gt;

&lt;p&gt;  好了，有这些概念打底，可以说fork了。当你的程序执行到下面的语句：pid=fork();操作系统创建一个新的进程（子进程），并且在进程表中相应为它建立一个新的表项。新进程和原有进程的可执行程序是同一个程序；上下文和数据，绝大部分就是原进程（父进程）的拷贝，但它们是两个相互独立的进程！此时程序寄存器pc，在父、子进程的上下文中都声称，这个进程目前执行到fork调用即将返回（此时子进程不占有CPU，子进程的pc不是真正保存在寄存器中，而是作为进程上下文保存在进程表中的对应表项内）。问题是怎么返回，在父子进程中就分道扬镳。 &lt;/p&gt;

&lt;p&gt;  父进程继续执行，操作系统对fork的实现，使这个调用在父进程中返回刚刚创建的子进程的pid（一个正整数），所以下面的if语句中pid&amp;lt;0, pid==0的两个分支都不会执行。所以输出i am the parent process… 子进程在之后的某个时候得到调度，它的上下文被换入，占据 CPU，操作系统对fork的实现，使得子进程中fork调用返回0。所以在这个进程（注意这不是父进程了哦，虽然是同一个程序，但是这是同一个程序的另外一次执行，在操作系统中这次执行是由另外一个进程表示的，从执行的角度说和父进程相互独立）中pid=0。这个进程继续执行的过程中，if语句中pid&amp;lt;0不满足，但是pid==0是true。所以输出i am the child process… 我想你比较困惑的就是，为什么看上去程序中互斥的两个分支都被执行了。在一个程序的一次执行中，这当然是不可能的；但是你看到的两行输出是来自两个进程，这两个进程来自同一个程序的两次执行。我的天，不知道说明白了没……  &lt;/p&gt;

&lt;p&gt;  fork之后，操作系统会复制一个与父进程完全相同的子进程，虽说是父子关系，但是在操作系统看来，他们更像兄弟关系，这2个进程共享代码空间，但是数据空间是互相独立的，子进程数据空间中的内容是父进程的完整拷贝，指令指针也完全相同，但只有一点不同，如果fork成功，子进程中fork的返回值是0，父进程中fork的返回值是子进程的进程号，如果fork不成功，父进程会返回错误。可以这样想象，2个进程一直同时运行，而且步调一致，在fork之后，他们分别作不同的工作，也就是分岔了。这也是fork为什么叫fork的原因。至于那一个最先运行，可能与操作系统有关，而且这个问题在实际应用中并不重要，如果需要父子进程协同，可以通过原语的办法解决。  &lt;/p&gt;

&lt;p&gt;  fork()成功时对父进程返回子进程的进程号，对子进程返回0，因此，如果有在子进程中需要使用进程id对情况，可以通过getpid()获取。  &lt;/p&gt;

&lt;p&gt;  完！&lt;/p&gt;

</description>
				<pubDate>Thu, 15 Sep 2011 00:00:00 +0800</pubDate>
				<link>/linux/2011/09/15/fork.html</link>
				<guid isPermaLink="true">/linux/2011/09/15/fork.html</guid>
			</item>
		
	</channel>
</rss>
